# Small Problems

Goal of this chapter is to get familiar with a couple of problem-solving techniques. Problems:

## 1. 1 The Fibonacci Sequence

A series that a number is produced by sum of the two previous number, except for the first two numbers:

$0, 1, 1, 2, 3, 5, 8, 13, 21$

$fib(n) = fib(n - 1) + fib(n - 2)$

1.1.1 A first recursive attempt - without base cases.

1.1.2 utilizing base cases (base case; recursion case)

1.1.3 memoization to the rescue

1.1.4 automatic memoization

1.1.5 keep it simple, Fibonacci: Iterative solution is way faster the recursive one [[1](https://stackoverflow.com/questions/63656099/why-is-fibonacci-iterative-slower-than-the-recursive-version-with-memoization)].

1.1.6 Generating Fibonacci numbers with a generator

## 1.2 Trivial compression

Compression is a trade-off between time and space. In high-level programming language sometimes you see such a waste of memory to make it more readable. Python does not have a bit-string off-the-shelf, let's do something similar to that to understand the idea of compression.

## 1.3 Unbreakable encryption

This problem is about one-time pad, which

To be unbreakable, dummy data must:

1. be the same length as the original data.
2. Truly random
3. Completely secret

## 1.4 Calculating pi

The idea behind this problem is to model a mathematic formula into some code.

## 1.5 The Towers of Hanoi

More of recursive functions; importance of the base case.



